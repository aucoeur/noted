
<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>Nota Bene</title>

    <style media="screen">
      .highlight table td { padding: 5px; }
.highlight table pre { margin: 0; }
.highlight .gh {
  color: #999999;
}
.highlight .sr {
  color: #f6aa11;
}
.highlight .go {
  color: #888888;
}
.highlight .gp {
  color: #555555;
}
.highlight .gs {
}
.highlight .gu {
  color: #aaaaaa;
}
.highlight .nb {
  color: #f6aa11;
}
.highlight .cm {
  color: #75715e;
}
.highlight .cp {
  color: #75715e;
}
.highlight .c1 {
  color: #75715e;
}
.highlight .cs {
  color: #75715e;
}
.highlight .c, .highlight .ch, .highlight .cd, .highlight .cpf {
  color: #75715e;
}
.highlight .err {
  color: #960050;
}
.highlight .gr {
  color: #960050;
}
.highlight .gt {
  color: #960050;
}
.highlight .gd {
  color: #49483e;
}
.highlight .gi {
  color: #49483e;
}
.highlight .ge {
  color: #49483e;
}
.highlight .kc {
  color: #66d9ef;
}
.highlight .kd {
  color: #66d9ef;
}
.highlight .kr {
  color: #66d9ef;
}
.highlight .no {
  color: #66d9ef;
}
.highlight .kt {
  color: #66d9ef;
}
.highlight .mf {
  color: #ae81ff;
}
.highlight .mh {
  color: #ae81ff;
}
.highlight .il {
  color: #ae81ff;
}
.highlight .mi {
  color: #ae81ff;
}
.highlight .mo {
  color: #ae81ff;
}
.highlight .m, .highlight .mb, .highlight .mx {
  color: #ae81ff;
}
.highlight .sc {
  color: #ae81ff;
}
.highlight .se {
  color: #ae81ff;
}
.highlight .ss {
  color: #ae81ff;
}
.highlight .sd {
  color: #e6db74;
}
.highlight .s2 {
  color: #e6db74;
}
.highlight .sb {
  color: #e6db74;
}
.highlight .sh {
  color: #e6db74;
}
.highlight .si {
  color: #e6db74;
}
.highlight .sx {
  color: #e6db74;
}
.highlight .s1 {
  color: #e6db74;
}
.highlight .s, .highlight .sa, .highlight .dl {
  color: #e6db74;
}
.highlight .na {
  color: #a6e22e;
}
.highlight .nc {
  color: #a6e22e;
}
.highlight .nd {
  color: #a6e22e;
}
.highlight .ne {
  color: #a6e22e;
}
.highlight .nf, .highlight .fm {
  color: #a6e22e;
}
.highlight .vc {
  color: #ffffff;
}
.highlight .nn {
  color: #ffffff;
}
.highlight .ni {
  color: #ffffff;
}
.highlight .bp {
  color: #ffffff;
}
.highlight .vg {
  color: #ffffff;
}
.highlight .vi {
  color: #ffffff;
}
.highlight .nv, .highlight .vm {
  color: #ffffff;
}
.highlight .w {
  color: #ffffff;
}
.highlight {
  color: #ffffff;
}
.highlight .n, .highlight .py, .highlight .nx {
  color: #ffffff;
}
.highlight .nl {
  color: #f92672;
}
.highlight .ow {
  color: #f92672;
}
.highlight .nt {
  color: #f92672;
}
.highlight .k, .highlight .kv {
  color: #f92672;
}
.highlight .kn {
  color: #f92672;
}
.highlight .kp {
  color: #f92672;
}
.highlight .o {
  color: #f92672;
}
    </style>
    <style media="print">
      * {
        -webkit-transition:none!important;
        transition:none!important;
      }
      .highlight table td { padding: 5px; }
.highlight table pre { margin: 0; }
.highlight, .highlight .w {
  color: #586e75;
}
.highlight .err {
  color: #002b36;
  background-color: #dc322f;
}
.highlight .c, .highlight .ch, .highlight .cd, .highlight .cm, .highlight .cpf, .highlight .c1, .highlight .cs {
  color: #657b83;
}
.highlight .cp {
  color: #b58900;
}
.highlight .nt {
  color: #b58900;
}
.highlight .o, .highlight .ow {
  color: #93a1a1;
}
.highlight .p, .highlight .pi {
  color: #93a1a1;
}
.highlight .gi {
  color: #859900;
}
.highlight .gd {
  color: #dc322f;
}
.highlight .gh {
  color: #268bd2;
  background-color: #002b36;
  font-weight: bold;
}
.highlight .k, .highlight .kn, .highlight .kp, .highlight .kr, .highlight .kv {
  color: #6c71c4;
}
.highlight .kc {
  color: #cb4b16;
}
.highlight .kt {
  color: #cb4b16;
}
.highlight .kd {
  color: #cb4b16;
}
.highlight .s, .highlight .sb, .highlight .sc, .highlight .dl, .highlight .sd, .highlight .s2, .highlight .sh, .highlight .sx, .highlight .s1 {
  color: #859900;
}
.highlight .sa {
  color: #6c71c4;
}
.highlight .sr {
  color: #2aa198;
}
.highlight .si {
  color: #d33682;
}
.highlight .se {
  color: #d33682;
}
.highlight .nn {
  color: #b58900;
}
.highlight .nc {
  color: #b58900;
}
.highlight .no {
  color: #b58900;
}
.highlight .na {
  color: #268bd2;
}
.highlight .m, .highlight .mb, .highlight .mf, .highlight .mh, .highlight .mi, .highlight .il, .highlight .mo, .highlight .mx {
  color: #859900;
}
.highlight .ss {
  color: #859900;
}
    </style>
    <link href="stylesheets/screen-97c7ecb2.css" rel="stylesheet" media="screen" />
    <link href="stylesheets/print-36b61a55.css" rel="stylesheet" media="print" />
      <script src="javascripts/all-a9fde460.js"></script>

    <script>
      $(function() { setupCodeCopy(); });
    </script>
  </head>

  <body class="index" data-languages="[&quot;python&quot;,&quot;markdown&quot;]">
    <a href="#" id="nav-button">
      <span>
        NAV
        <img src="images/navbar-cad8cdcb.png" alt="" />
      </span>
    </a>
    <div class="toc-wrapper">
      <img src="images/logo-04d75614.png" class="logo" alt="" />
        <div class="lang-selector">
              <a href="#" data-language-name="python">python</a>
              <a href="#" data-language-name="markdown">pseudocode</a>
        </div>
        <div class="search">
          <input type="text" class="search" id="input-search" placeholder="Search">
        </div>
        <ul class="search-results"></ul>
      <ul id="toc" class="toc-list-h1">
          <li>
            <a href="#data-structures-amp-algorithms" class="toc-h1 toc-link" data-title="Data Structures &amp; Algorithms">Data Structures &amp; Algorithms</a>
          </li>
          <li>
            <a href="#linkedlists" class="toc-h1 toc-link" data-title="LinkedLists">LinkedLists</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#terminology" class="toc-h2 toc-link" data-title="Terminology">Terminology</a>
                  </li>
                  <li>
                    <a href="#time-amp-space-complexity" class="toc-h2 toc-link" data-title="Time &amp; Space Complexity">Time &amp; Space Complexity</a>
                  </li>
                  <li>
                    <a href="#strategy-dummy-head" class="toc-h2 toc-link" data-title="Strategy: Dummy Head">Strategy: Dummy Head</a>
                  </li>
                  <li>
                    <a href="#strategy-multi-pass" class="toc-h2 toc-link" data-title="Strategy:  Multi Pass">Strategy:  Multi Pass</a>
                  </li>
                  <li>
                    <a href="#note-on-recursion-vs-iteration" class="toc-h2 toc-link" data-title="Note on Recursion vs. Iteration:">Note on Recursion vs. Iteration:</a>
                  </li>
                  <li>
                    <a href="#strategy-two-pointer" class="toc-h2 toc-link" data-title="Strategy: Two Pointer">Strategy: Two Pointer</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#heaps" class="toc-h1 toc-link" data-title="Heaps">Heaps</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#terminology" class="toc-h2 toc-link" data-title="Terminology">Terminology</a>
                  </li>
                  <li>
                    <a href="#heap-operations" class="toc-h2 toc-link" data-title="Heap Operations">Heap Operations</a>
                  </li>
                  <li>
                    <a href="#building" class="toc-h2 toc-link" data-title="Building">Building</a>
                  </li>
                  <li>
                    <a href="#insertion" class="toc-h2 toc-link" data-title="Insertion">Insertion</a>
                  </li>
                  <li>
                    <a href="#removal" class="toc-h2 toc-link" data-title="Removal">Removal</a>
                  </li>
                  <li>
                    <a href="#time-complexity" class="toc-h2 toc-link" data-title="Time Complexity">Time Complexity</a>
                  </li>
                  <li>
                    <a href="#references" class="toc-h2 toc-link" data-title="References">References</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#references" class="toc-h1 toc-link" data-title="References">References</a>
          </li>
      </ul>
        <ul class="toc-footer">
            <li><a href='https://github.com/slatedocs/slate'>Documentation Powered by Slate</a></li>
        </ul>
    </div>
    <div class="page-wrapper">
      <div class="dark-box"></div>
      <div class="content">
        <h1 id='data-structures-amp-algorithms'>Data Structures &amp; Algorithms</h1>
<p>Werkkk</p>
<h1 id='linkedlists'>LinkedLists</h1>
<blockquote>
<p>Definition of a Node</p>
</blockquote>
<div class="highlight"><pre class="highlight python tab-python"><code><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nb">next</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">previous</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="nb">next</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">previous</span> <span class="o">=</span> <span class="n">previous</span> <span class="c1"># if Doubly Linked
</span></code></pre></div><div class="highlight"><pre class="highlight markdown tab-markdown"><code><span class="p">-</span> Node holds two (or three) things:
<span class="p">    -</span> the data
<span class="p">    -</span> pointer to the next node
<span class="p">    -</span> pointer to previous node (if doubly linked list)
</code></pre></div>
<blockquote>
<p>Definition of Singly LinkedList</p>
</blockquote>
<div class="highlight"><pre class="highlight python tab-python"><code><span class="k">class</span> <span class="nc">LinkedList</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">items</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">tail</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="n">items</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">prepend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">:</span> <span class="c1"># empty LL -&gt; node set to head &amp; tail 
</span>            <span class="bp">self</span><span class="p">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">node</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="n">node</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">head</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">node</span> 

    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">.</span><span class="n">tail</span><span class="p">:</span> <span class="c1"># empty LL -&gt; node set to head &amp; tail 
</span>            <span class="bp">self</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">node</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">tail</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">node</span> 
        <span class="bp">self</span><span class="p">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">node</span>
    <span class="c1"># ...   
</span></code></pre></div><div class="highlight"><pre class="highlight markdown tab-markdown"><code><span class="p">-</span> LinkedList init with head &amp; tail node, if exists
<span class="p">-</span> If init with array, create the list with append()
</code></pre></div>
<p>The most common variants of linked lists are:</p>

<table><thead>
<tr>
<th></th>
<th style="text-align: center"><code>next</code></th>
<th style="text-align: center"><code>previous</code></th>
<th>if Circular:</th>
</tr>
</thead><tbody>
<tr>
<td>Singly Linked</td>
<td style="text-align: center">☑️</td>
<td style="text-align: center"></td>
<td><code>tail.next</code> -&gt; <code>head</code></td>
</tr>
<tr>
<td>Doubly Linked</td>
<td style="text-align: center">☑️</td>
<td style="text-align: center">☑️</td>
<td><code>tail.next</code> -&gt; <code>head</code> <br /> <code>head.previous</code> -&gt; <code>tail</code></td>
</tr>
</tbody></table>
<h3 id='terminology'>Terminology</h3>
<table><thead>
<tr>
<th></th>
<th></th>
</tr>
</thead><tbody>
<tr>
<td>node</td>
<td>position in LinkedList containing the <code>value</code> of whatever is stored at the position and at least one reference to another node (<code>next</code>)</td>
</tr>
<tr>
<td>head</td>
<td>node at <code>beginning</code> of list</td>
</tr>
<tr>
<td>tail</td>
<td>node at <code>end</code> of the list</td>
</tr>
<tr>
<td>sentinel</td>
<td>a <code>dummy</code> node, typically placed at the head or end of the list to help make operations simpler (e.g., delete) or to indicate the termination of list</td>
</tr>
</tbody></table>
<h3 id='time-amp-space-complexity'>Time &amp; Space Complexity</h3>
<table><thead>
<tr>
<th style="text-align: right"></th>
<th style="text-align: center">Best</th>
<th style="text-align: center">Worst</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: right"><em>Occurs when <code>node</code> at</em></td>
<td style="text-align: center"><code>head</code></td>
<td style="text-align: center"><code>last</code></td>
</tr>
<tr>
<td style="text-align: right">Accessing / Search</td>
<td style="text-align: center">O(1)</td>
<td style="text-align: center">O(N)</td>
</tr>
<tr>
<td style="text-align: right">Inserting at <code>head</code></td>
<td style="text-align: center">O(1)</td>
<td style="text-align: center">O(N)</td>
</tr>
<tr>
<td style="text-align: right">Deleting at <code>head</code></td>
<td style="text-align: center">O(1)</td>
<td style="text-align: center">O(N)</td>
</tr>
</tbody></table>
<h2 id='strategy-dummy-head'>Strategy: Dummy Head</h2>
<blockquote>
<p>Delete</p>
</blockquote>
<div class="highlight"><pre class="highlight python tab-python"><code>    <span class="k">def</span> <span class="nf">delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="n">dummy</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="s">"sentinel"</span><span class="p">)</span>
        <span class="n">dummy</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">placeholder</span> <span class="o">=</span> <span class="n">dummy</span>
        <span class="n">current</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">while</span> <span class="n">current</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">current</span><span class="p">.</span><span class="n">val</span> <span class="o">==</span> <span class="n">val</span><span class="p">:</span>
                <span class="n">placeholder</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">current</span><span class="p">.</span><span class="nb">next</span>
                <span class="k">return</span> <span class="n">dummy</span><span class="p">.</span><span class="nb">next</span>
            <span class="n">placeholder</span> <span class="o">=</span> <span class="n">current</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="p">.</span><span class="nb">next</span>
        <span class="k">return</span> <span class="n">dummy</span><span class="p">.</span><span class="nb">next</span>         
</code></pre></div><div class="highlight"><pre class="highlight markdown tab-markdown"><code><span class="p">1.</span> Create <span class="sb">`dummy`</span> node
<span class="p">    -</span> <span class="sb">`dummy.next`</span> points to <span class="sb">`head`</span>
<span class="p">2.</span> Set <span class="sb">`placeholder`</span> to <span class="sb">`dummy`</span> and <span class="sb">`current`</span> to <span class="sb">`head`</span>
<span class="p">3.</span> Iterate through <span class="sb">`current`</span> by:
<span class="p">    -</span> Set <span class="sb">`placeholder`</span> to <span class="sb">`current`</span> node
<span class="p">    -</span> Set <span class="sb">`current`</span> to <span class="sb">`current.next`</span>
<span class="p">5.</span> If we find <span class="sb">`val`</span>:
<span class="p">    -</span> set <span class="sb">`placeholder.next`</span> to node at <span class="sb">`current.next`</span>
<span class="p">6.</span> Return <span class="sb">`dummy.next`</span>

</code></pre></div>
<p>Typically saves you creating <em>special edge condition logic</em> in order to operate on the head of a linked list with some algorithms. </p>

<aside class="notice">
Thanks to `dummy head`, deleting the head of the original list is the same as deleting any other element in the list.
</aside>
<h2 id='strategy-multi-pass'>Strategy:  Multi Pass</h2>
<blockquote>
<p>Get Length of List</p>
</blockquote>
<div class="highlight"><pre class="highlight python tab-python"><code>    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">current</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">length</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">current</span><span class="p">:</span>
            <span class="n">length</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="p">.</span><span class="nb">next</span>
        <span class="k">return</span> <span class="n">length</span>
</code></pre></div><div class="highlight"><pre class="highlight markdown tab-markdown"><code><span class="p">1.</span> Iterate through list
<span class="p">2.</span> Increment <span class="sb">`length`</span>
<span class="p">3.</span> Set <span class="sb">`current`</span> to <span class="sb">`current.next`</span>
</code></pre></div>
<p>Most computations on a list will require O(N) time complexity, so a simple but very useful technique is to pass through the list a constant number of times to calculate some summary of the list that will simplify your algorithm.</p>

<p>The looping is implicitly done for you by the execution of your program, namely every successive call to your recursive function places some data on your <code>call stack</code> and then goes to the next function.</p>
<h2 id='note-on-recursion-vs-iteration'>Note on Recursion vs. Iteration:</h2>
<blockquote>
<p>Recursive Length of List</p>
</blockquote>
<div class="highlight"><pre class="highlight python tab-python"><code>    <span class="k">def</span> <span class="nf">get_length_recursive</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">linklist</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">linklist</span><span class="p">:</span> 
            <span class="k">return</span> <span class="mi">0</span> <span class="c1"># A None path has 0 length
</span>        <span class="k">return</span> <span class="n">get_length_recursive</span><span class="p">(</span><span class="n">linklist</span><span class="p">.</span><span class="nb">next</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> 
        <span class="c1"># The length at this node is 1 + length of rest of list
</span></code></pre></div><div class="highlight"><pre class="highlight markdown tab-markdown"><code><span class="p">1.</span> Base Case: return <span class="sb">`0`</span> if <span class="sb">`None`</span>
<span class="p">2.</span> Recurse through call stack, 
adding <span class="sb">`+1`</span> to previous val of <span class="sb">`length`</span> on call stack
</code></pre></div>
<aside class="notice"> 
Recursive algorithms are often very easy to write with linked lists because the list is structured recursively.
</aside>

<aside class="warning">
Major drawback of recursive algorithm. For most situations, this means you are paying a storage penalty equal to the size of the list.
</aside>
<h2 id='strategy-two-pointer'>Strategy: Two Pointer</h2>
<blockquote>
<p>Two-Pointer Solution for Detecting Cycle</p>
</blockquote>
<div class="highlight"><pre class="highlight python tab-python"><code><span class="k">def</span> <span class="nf">has_cycle</span><span class="p">(</span><span class="n">ll</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ll</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">ll</span><span class="p">.</span><span class="nb">next</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="n">slow</span> <span class="o">=</span> <span class="n">ll</span>
    <span class="n">fast</span> <span class="o">=</span> <span class="n">ll</span><span class="p">.</span><span class="nb">next</span>

    <span class="k">while</span> <span class="n">fast</span> <span class="ow">and</span> <span class="n">fast</span><span class="p">.</span><span class="nb">next</span><span class="p">:</span>

        <span class="k">if</span> <span class="n">fast</span> <span class="o">==</span> <span class="n">slow</span> <span class="ow">or</span> <span class="n">fast</span><span class="p">.</span><span class="nb">next</span> <span class="o">==</span> <span class="n">slow</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="nb">next</span> <span class="c1"># Because it's fast
</span>        <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="p">.</span><span class="nb">next</span>
    <span class="k">return</span> <span class="bp">False</span>
</code></pre></div><div class="highlight"><pre class="highlight markdown tab-markdown"><code>Similar to a race track,   
the faster pointer will eventually cross/lap the slower pointer,   
whereas if no cycle, they will never cross paths  
</code></pre></div>
<p>Very useful technique for dealing with linked lists involves iterating through the list with 2 or more pointers. </p>

<p>The differences between how the pointers iterate can be used to make calculations on the list more efficient.</p>

<table><thead>
<tr>
<th></th>
<th>Time</th>
<th>Space</th>
</tr>
</thead><tbody>
<tr>
<td>Using Hashmap</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>Two Pointer</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<h3 id='explanation'>Explanation:</h3>
<p>The first thing that most people think of is to use another data structure to store nodes that we have already seen as we traverse the list. Then as we move through the nodes of the list we check to see if we have already stored the current node in our auxiliary data structure and if we have then we have found a cycle. The typical data structure to choose here is a hash map because it offers constant time insertion and lookup. </p>

<p>We can get rid of the extra auxiliary data structure by utilizing only one additional pointer. We can then use the two pointers to iterate through the list at two different speeds. The motivation being that if there is a cycle, then the list can be thought of as a circle (at least the part of the list past the self-intersection). Similar to a race track, the faster pointer must eventually cross paths with the slower pointer, whereas if there is not a cycle they will never cross paths.</p>
<h1 id='heaps'>Heaps</h1>
<blockquote>
<p>Min Heap</p>
</blockquote>
<div class="highlight"><pre class="highlight markdown tab-markdown"><code>           1 &lt;- smallest
         /   <span class="err">\</span>
        3      2
       / <span class="se">\ </span>   /
      4   6  5
</code></pre></div><div class="highlight"><pre class="highlight python tab-python"><code><span class="kn">import</span> <span class="nn">heapq</span>

<span class="k">class</span> <span class="nc">MinHeap</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">minheap</span><span class="p">):</span> <span class="c1"># minheap is the list that we can to convert to a heap
</span>        <span class="n">heapq</span><span class="p">.</span><span class="n">heapify</span><span class="p">(</span><span class="n">minheap</span><span class="p">)</span> <span class="c1"># Use the heapify function to convert list to a heap
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">minheap</span> <span class="o">=</span> <span class="n">minheap</span>

    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="n">heapq</span><span class="p">.</span><span class="n">heappush</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">minheap</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="c1"># Insert key into the heap (heapq automatically maintains the heap property)
</span>
    <span class="k">def</span> <span class="nf">getMin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">minheap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># Returns the smallest element of the heap in O(1) time
</span>
    <span class="k">def</span> <span class="nf">removeMin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">heapq</span><span class="p">.</span><span class="n">heappop</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">minheap</span><span class="p">)</span> <span class="c1"># The heappop function removes the smallest element in the heap
</span>
    <span class="k">def</span> <span class="nf">printHeap</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">minheap</span><span class="p">)</span> <span class="c1"># Prints the heap
</span></code></pre></div>
<p>Heaps are special tree based data structures that satisfy two properties:</p>

<ol>
<li><p>Ordered in a specific way:</p>

<table><thead>
<tr>
<th>heaps</th>
<th style="text-align: left"><code>root</code></th>
<th>children</th>
</tr>
</thead><tbody>
<tr>
<td>Min</td>
<td style="text-align: left">smallest element</td>
<td><code>parent &lt;=</code> sum of <code>children</code></td>
</tr>
<tr>
<td>Max</td>
<td style="text-align: left">largest element</td>
<td><code>parent &gt;=</code> sum of <code>children</code></td>
</tr>
</tbody></table></li>
<li><p>Are <strong>complete binary trees</strong>     </p>

<table><thead>
<tr>
<th></th>
<th></th>
</tr>
</thead><tbody>
<tr>
<td>Binary</td>
<td>At most, two children: <code>left</code> and <code>right</code></td>
</tr>
<tr>
<td>Complete</td>
<td>Fills each level entirely, except the last level, which <strong>must</strong> be <code>left</code></td>
</tr>
</tbody></table></li>
</ol>

<p>Heaps are useful when for getting the largest or smallest elements, and in situations where you don’t care about fast lookup, delete, or search.</p>
<h3 id='terminology'>Terminology</h3>
<blockquote>
<p>Max Heap</p>
</blockquote>
<div class="highlight"><pre class="highlight markdown tab-markdown"><code>           6 &lt;- largest
         /   <span class="err">\</span>
        5     3
       / <span class="se">\ </span>   /
      4   2  1
</code></pre></div><div class="highlight"><pre class="highlight python tab-python"><code><span class="k">class</span> <span class="nc">MaxHeap</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Initialize a heap using list
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">heap</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">getParentPosition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="c1"># The parent is located at floor((i-1)/2)
</span>        <span class="k">return</span> <span class="nb">int</span><span class="p">((</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getLeftChildPosition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="c1"># The left child is located at 2 * i + 1
</span>        <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span>

    <span class="k">def</span> <span class="nf">getRightChildPosition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="c1"># The right child is located at 2 * i + 2
</span>        <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span>

    <span class="k">def</span> <span class="nf">hasParent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="c1"># This function checks if the given node has a parent or not
</span>        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">getParentPosition</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">heap</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">hasLeftChild</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="c1"># This function checks if the given node has a left child or not
</span>        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">getLeftChildPosition</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">heap</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">hasRightChild</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="c1"># This function checks if the given node has a right child or not
</span>        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">getRightChildPosition</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">heap</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">heap</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="c1"># Adds the key to the end of the list
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">heapify</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">heap</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># Re-arranges the heap to maintain the heap property
</span>
    <span class="k">def</span> <span class="nf">getMax</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">heap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># Returns the largest value in the heap in O(1) time.
</span>
    <span class="k">def</span> <span class="nf">heapify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="k">while</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">hasParent</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="p">.</span><span class="n">heap</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="p">.</span><span class="n">heap</span><span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">getParentPosition</span><span class="p">(</span><span class="n">i</span><span class="p">)]):</span> <span class="c1"># Loops until it reaches a leaf node
</span>            <span class="bp">self</span><span class="p">.</span><span class="n">heap</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="p">.</span><span class="n">heap</span><span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">getParentPosition</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">heap</span><span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">getParentPosition</span><span class="p">(</span><span class="n">i</span><span class="p">)],</span> <span class="bp">self</span><span class="p">.</span><span class="n">heap</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="c1"># Swap the values
</span>            <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">getParentPosition</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="c1"># Resets the new position
</span>
    <span class="k">def</span> <span class="nf">printHeap</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">heap</span><span class="p">)</span> <span class="c1"># Prints the heap
</span></code></pre></div>
<table><thead>
<tr>
<th></th>
<th></th>
</tr>
</thead><tbody>
<tr>
<td>Bubble down</td>
<td>moving an element down by swapping with one of its children in proper position</td>
</tr>
<tr>
<td>Bubble up</td>
<td>moving an element down by swapping with one of its children in proper position</td>
</tr>
<tr>
<td>Priority Queue</td>
<td>queue data structure with associated priority value, higher priority is dequeue before lower priority, if same, then dequeued based on location in array</td>
</tr>
</tbody></table>
<h3 id='heap-operations'>Heap Operations</h3><h3 id='building'>Building</h3>
<p>This complex data structure can be represented using an array. Often implemented as arrays because they are super efficient ways of representing <em>priority queues</em>.</p>

<p><em>Binary heaps</em> are super efficient for implementing priority queues because it’s very easy to know and retrieve/remove the element with the highest priority: <em>it will always be the **root</em>* node*!</p>

<p>Building a heap only takes <code>O(n)</code> time, so you can potentially optimize a solution by building a heap from a list instead of running <em>insertion</em> <code>n</code> times to create the heap.</p>

<p>By property of it being a complete binary tree, we can see how the parent-child relationships are maintained in the array using these formulas: </p>

<table><thead>
<tr>
<th></th>
<th style="text-align: center"></th>
<th></th>
</tr>
</thead><tbody>
<tr>
<td>Parent</td>
<td style="text-align: center"><code>(n - 1) // 2</code></td>
<td><code>n ==</code> index of current node</td>
</tr>
<tr>
<td><code>Left</code></td>
<td style="text-align: center"><code>2i + 1</code></td>
<td><code>i ==</code> index of parent node</td>
</tr>
<tr>
<td><code>Right</code></td>
<td style="text-align: center"><code>2i + 2</code></td>
<td></td>
</tr>
</tbody></table>
<h3 id='insertion'>Insertion</h3>
<p>When growing a heap, we can only ever add a node to the <code>left-most</code> available node, at <code>lowest possible level</code>.</p>

<p>If necessary to follow both rules of shape and order, we <code>swap</code> the two nodes that are out of order</p>
<h3 id='removal'>Removal</h3>
<p>When deleting or removing an element, most heaps are usually concerned with removing the <code>root</code> node.</p>

<p>In order to maintain rules of shape and order: </p>

<ol>
<li>For shape, remove the <code>right-most</code> node at the <code>lowest level</code>, make it <code>root</code></li>
<li>Then, for order, compare with child nodes and <code>swap</code></li>
<li>Continue bubbling down (step 2) until no longer violating <code>heap order property</code></li>
</ol>
<h2 id='time-complexity'>Time Complexity</h2>
<p>In the worst case scenario, the swapping procedure for insertions and deletions will move the element through the height of the heap. </p>

<p>Because heaps are binary trees that are guaranteed to be as complete as possible, the number of levels in the heap will be <code>log n</code>.</p>

<table><thead>
<tr>
<th style="text-align: right"></th>
<th style="text-align: center">Best</th>
<th style="text-align: center">Worst</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: right">Reading root node</td>
<td style="text-align: center">O(1)</td>
<td style="text-align: center">O(1)</td>
</tr>
<tr>
<td style="text-align: right">Insertion</td>
<td style="text-align: center">O(log n)</td>
<td style="text-align: center">O(log n)</td>
</tr>
<tr>
<td style="text-align: right">Deletion</td>
<td style="text-align: center">O(log n)</td>
<td style="text-align: center">O(log n)</td>
</tr>
<tr>
<td style="text-align: right">Build heap</td>
<td style="text-align: center">O(n) (from list)</td>
<td style="text-align: center">O(n log n) (inserting into empty heap)</td>
</tr>
</tbody></table>
<h2 id='references'>References</h2>
<ul>
<li><a href="https://medium.com/basecs/learning-to-love-heaps-cef2b273a238">https://medium.com/basecs/learning-to-love-heaps-cef2b273a238</a> </li>
<li><a href="https://www.geeksforgeeks.org/binary-heap/">https://www.geeksforgeeks.org/binary-heap/</a></li>
<li><a href="https://www.section.io/engineering-education/heap-data-structure-python/">https://www.section.io/engineering-education/heap-data-structure-python/</a></li>
</ul>
<h1 id='references'>References</h1>
<ul>
<li>CodePath CS guides: <a href="https://guides.codepath.org/compsci">https://guides.codepath.org/compsci</a></li>
<li>InterviewCake: <a href="https://www.interviewcake.com/data-structures-reference">https://www.interviewcake.com/data-structures-reference</a></li>
<li>TSiege Tech Interview Cheat Sheet: <a href="https://github.com/TSiege/Tech-Interview-Cheat-Sheet">https://github.com/TSiege/Tech-Interview-Cheat-Sheet</a></li>
</ul>

      </div>
      <div class="dark-box">
          <div class="lang-selector">
                <a href="#" data-language-name="python">python</a>
                <a href="#" data-language-name="markdown">pseudocode</a>
          </div>
      </div>
    </div>
  </body>
</html>
