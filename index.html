
<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>Nota Bene</title>

    <style media="screen">
      .highlight table td { padding: 5px; }
.highlight table pre { margin: 0; }
.highlight .gh {
  color: #999999;
}
.highlight .sr {
  color: #f6aa11;
}
.highlight .go {
  color: #888888;
}
.highlight .gp {
  color: #555555;
}
.highlight .gs {
}
.highlight .gu {
  color: #aaaaaa;
}
.highlight .nb {
  color: #f6aa11;
}
.highlight .cm {
  color: #75715e;
}
.highlight .cp {
  color: #75715e;
}
.highlight .c1 {
  color: #75715e;
}
.highlight .cs {
  color: #75715e;
}
.highlight .c, .highlight .ch, .highlight .cd, .highlight .cpf {
  color: #75715e;
}
.highlight .err {
  color: #960050;
}
.highlight .gr {
  color: #960050;
}
.highlight .gt {
  color: #960050;
}
.highlight .gd {
  color: #49483e;
}
.highlight .gi {
  color: #49483e;
}
.highlight .ge {
  color: #49483e;
}
.highlight .kc {
  color: #66d9ef;
}
.highlight .kd {
  color: #66d9ef;
}
.highlight .kr {
  color: #66d9ef;
}
.highlight .no {
  color: #66d9ef;
}
.highlight .kt {
  color: #66d9ef;
}
.highlight .mf {
  color: #ae81ff;
}
.highlight .mh {
  color: #ae81ff;
}
.highlight .il {
  color: #ae81ff;
}
.highlight .mi {
  color: #ae81ff;
}
.highlight .mo {
  color: #ae81ff;
}
.highlight .m, .highlight .mb, .highlight .mx {
  color: #ae81ff;
}
.highlight .sc {
  color: #ae81ff;
}
.highlight .se {
  color: #ae81ff;
}
.highlight .ss {
  color: #ae81ff;
}
.highlight .sd {
  color: #e6db74;
}
.highlight .s2 {
  color: #e6db74;
}
.highlight .sb {
  color: #e6db74;
}
.highlight .sh {
  color: #e6db74;
}
.highlight .si {
  color: #e6db74;
}
.highlight .sx {
  color: #e6db74;
}
.highlight .s1 {
  color: #e6db74;
}
.highlight .s, .highlight .sa, .highlight .dl {
  color: #e6db74;
}
.highlight .na {
  color: #a6e22e;
}
.highlight .nc {
  color: #a6e22e;
}
.highlight .nd {
  color: #a6e22e;
}
.highlight .ne {
  color: #a6e22e;
}
.highlight .nf, .highlight .fm {
  color: #a6e22e;
}
.highlight .vc {
  color: #ffffff;
}
.highlight .nn {
  color: #ffffff;
}
.highlight .ni {
  color: #ffffff;
}
.highlight .bp {
  color: #ffffff;
}
.highlight .vg {
  color: #ffffff;
}
.highlight .vi {
  color: #ffffff;
}
.highlight .nv, .highlight .vm {
  color: #ffffff;
}
.highlight .w {
  color: #ffffff;
}
.highlight {
  color: #ffffff;
}
.highlight .n, .highlight .py, .highlight .nx {
  color: #ffffff;
}
.highlight .nl {
  color: #f92672;
}
.highlight .ow {
  color: #f92672;
}
.highlight .nt {
  color: #f92672;
}
.highlight .k, .highlight .kv {
  color: #f92672;
}
.highlight .kn {
  color: #f92672;
}
.highlight .kp {
  color: #f92672;
}
.highlight .o {
  color: #f92672;
}
    </style>
    <style media="print">
      * {
        -webkit-transition:none!important;
        transition:none!important;
      }
      .highlight table td { padding: 5px; }
.highlight table pre { margin: 0; }
.highlight, .highlight .w {
  color: #586e75;
}
.highlight .err {
  color: #002b36;
  background-color: #dc322f;
}
.highlight .c, .highlight .ch, .highlight .cd, .highlight .cm, .highlight .cpf, .highlight .c1, .highlight .cs {
  color: #657b83;
}
.highlight .cp {
  color: #b58900;
}
.highlight .nt {
  color: #b58900;
}
.highlight .o, .highlight .ow {
  color: #93a1a1;
}
.highlight .p, .highlight .pi {
  color: #93a1a1;
}
.highlight .gi {
  color: #859900;
}
.highlight .gd {
  color: #dc322f;
}
.highlight .gh {
  color: #268bd2;
  background-color: #002b36;
  font-weight: bold;
}
.highlight .k, .highlight .kn, .highlight .kp, .highlight .kr, .highlight .kv {
  color: #6c71c4;
}
.highlight .kc {
  color: #cb4b16;
}
.highlight .kt {
  color: #cb4b16;
}
.highlight .kd {
  color: #cb4b16;
}
.highlight .s, .highlight .sb, .highlight .sc, .highlight .dl, .highlight .sd, .highlight .s2, .highlight .sh, .highlight .sx, .highlight .s1 {
  color: #859900;
}
.highlight .sa {
  color: #6c71c4;
}
.highlight .sr {
  color: #2aa198;
}
.highlight .si {
  color: #d33682;
}
.highlight .se {
  color: #d33682;
}
.highlight .nn {
  color: #b58900;
}
.highlight .nc {
  color: #b58900;
}
.highlight .no {
  color: #b58900;
}
.highlight .na {
  color: #268bd2;
}
.highlight .m, .highlight .mb, .highlight .mf, .highlight .mh, .highlight .mi, .highlight .il, .highlight .mo, .highlight .mx {
  color: #859900;
}
.highlight .ss {
  color: #859900;
}
    </style>
    <link href="stylesheets/screen-b3953d61.css" rel="stylesheet" media="screen" />
    <link href="stylesheets/print-54cf1596.css" rel="stylesheet" media="print" />
      <script src="javascripts/all-a9fde460.js"></script>

    <script>
      $(function() { setupCodeCopy(); });
    </script>
  </head>

  <body class="index" data-languages="[&quot;python&quot;,&quot;markdown&quot;]">
    <a href="#" id="nav-button">
      <span>
        NAV
        <img src="images/navbar-cad8cdcb.png" alt="" />
      </span>
    </a>
    <div class="toc-wrapper">
      <img src="images/logo-04d75614.png" class="logo" alt="" />
        <div class="lang-selector">
              <a href="#" data-language-name="python">python</a>
              <a href="#" data-language-name="markdown">pseudocode</a>
        </div>
        <div class="search">
          <input type="text" class="search" id="input-search" placeholder="Search">
        </div>
        <ul class="search-results"></ul>
      <ul id="toc" class="toc-list-h1">
          <li>
            <a href="#data-structures-amp-algorithms" class="toc-h1 toc-link" data-title="Data Structures &amp; Algorithms">Data Structures &amp; Algorithms</a>
          </li>
          <li>
            <a href="#linkedlists" class="toc-h1 toc-link" data-title="LinkedLists">LinkedLists</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#terminology" class="toc-h2 toc-link" data-title="Terminology">Terminology</a>
                  </li>
                  <li>
                    <a href="#time-amp-space-complexity" class="toc-h2 toc-link" data-title="Time &amp; Space Complexity">Time &amp; Space Complexity</a>
                  </li>
                  <li>
                    <a href="#strategy-dummy-head" class="toc-h2 toc-link" data-title="Strategy: Dummy Head">Strategy: Dummy Head</a>
                  </li>
                  <li>
                    <a href="#strategy-multi-pass" class="toc-h2 toc-link" data-title="Strategy:  Multi Pass">Strategy:  Multi Pass</a>
                  </li>
                  <li>
                    <a href="#note-on-recursion-vs-iteration" class="toc-h2 toc-link" data-title="Note on Recursion vs. Iteration:">Note on Recursion vs. Iteration:</a>
                  </li>
                  <li>
                    <a href="#strategy-two-pointer" class="toc-h2 toc-link" data-title="Strategy: Two Pointer">Strategy: Two Pointer</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#references" class="toc-h1 toc-link" data-title="References">References</a>
          </li>
      </ul>
        <ul class="toc-footer">
            <li><a href='https://github.com/slatedocs/slate'>Documentation Powered by Slate</a></li>
        </ul>
    </div>
    <div class="page-wrapper">
      <div class="dark-box"></div>
      <div class="content">
        <h1 id='data-structures-amp-algorithms'>Data Structures &amp; Algorithms</h1>
<p>Werkkk</p>
<h1 id='linkedlists'>LinkedLists</h1>
<blockquote>
<p>Definition of a Node</p>
</blockquote>
<div class="highlight"><pre class="highlight python tab-python"><code><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nb">next</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">previous</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="nb">next</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">previous</span> <span class="o">=</span> <span class="n">previous</span> <span class="c1"># if Doubly Linked
</span></code></pre></div><div class="highlight"><pre class="highlight markdown tab-markdown"><code><span class="p">-</span> Node holds two (or three) things:
<span class="p">    -</span> the data
<span class="p">    -</span> pointer to the next node
<span class="p">    -</span> pointer to previous node (if doubly linked list)
</code></pre></div>
<blockquote>
<p>Definition of Singly LinkedList</p>
</blockquote>
<div class="highlight"><pre class="highlight python tab-python"><code><span class="k">class</span> <span class="nc">LinkedList</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">items</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">tail</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="n">items</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">prepend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">:</span> <span class="c1"># empty LL -&gt; node set to head &amp; tail 
</span>            <span class="bp">self</span><span class="p">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">node</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="n">node</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">head</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">node</span> 

    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">.</span><span class="n">tail</span><span class="p">:</span> <span class="c1"># empty LL -&gt; node set to head &amp; tail 
</span>            <span class="bp">self</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">node</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">tail</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">node</span> 
        <span class="bp">self</span><span class="p">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">node</span>
    <span class="c1"># ...   
</span></code></pre></div><div class="highlight"><pre class="highlight markdown tab-markdown"><code><span class="p">-</span> LinkedList init with head &amp; tail node, if exists
<span class="p">-</span> If init with array, create the list with append()
</code></pre></div>
<p>The most common variants of linked lists are:</p>

<table><thead>
<tr>
<th></th>
<th style="text-align: center"><code>next</code></th>
<th style="text-align: center"><code>previous</code></th>
<th>if Circular:</th>
</tr>
</thead><tbody>
<tr>
<td>Singly Linked</td>
<td style="text-align: center">☑️</td>
<td style="text-align: center"></td>
<td><code>tail.next</code> -&gt; <code>head</code></td>
</tr>
<tr>
<td>Doubly Linked</td>
<td style="text-align: center">☑️</td>
<td style="text-align: center">☑️</td>
<td><code>tail.next</code> -&gt; <code>head</code> <br /> <code>head.previous</code> -&gt; <code>tail</code></td>
</tr>
</tbody></table>
<h3 id='terminology'>Terminology</h3>
<table><thead>
<tr>
<th></th>
<th></th>
</tr>
</thead><tbody>
<tr>
<td>node</td>
<td>position in LinkedList containing the <code>value</code> of whatever is stored at the position and at least one reference to another node (<code>next</code>)</td>
</tr>
<tr>
<td>head</td>
<td>node at <code>beginning</code> of list</td>
</tr>
<tr>
<td>tail</td>
<td>node at <code>end</code> of the list</td>
</tr>
<tr>
<td>sentinel</td>
<td>a <code>dummy</code> node, typically placed at the head or end of the list to help make operations simpler (e.g., delete) or to indicate the termination of list</td>
</tr>
</tbody></table>
<h3 id='time-amp-space-complexity'>Time &amp; Space Complexity</h3>
<table><thead>
<tr>
<th style="text-align: right"></th>
<th style="text-align: center">Best</th>
<th style="text-align: center">Worst</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: right"><em>Occurs when <code>node</code> at</em></td>
<td style="text-align: center"><code>head</code></td>
<td style="text-align: center"><code>last</code></td>
</tr>
<tr>
<td style="text-align: right">Accessing / Search</td>
<td style="text-align: center">O(1)</td>
<td style="text-align: center">O(N)</td>
</tr>
<tr>
<td style="text-align: right">Inserting at <code>head</code></td>
<td style="text-align: center">O(1)</td>
<td style="text-align: center">O(N)</td>
</tr>
<tr>
<td style="text-align: right">Deleting at <code>head</code></td>
<td style="text-align: center">O(1)</td>
<td style="text-align: center">O(N)</td>
</tr>
</tbody></table>
<h2 id='strategy-dummy-head'>Strategy: Dummy Head</h2>
<blockquote>
<p>Delete</p>
</blockquote>
<div class="highlight"><pre class="highlight python tab-python"><code>    <span class="k">def</span> <span class="nf">delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="n">dummy</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="s">"sentinel"</span><span class="p">)</span>
        <span class="n">dummy</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">placeholder</span> <span class="o">=</span> <span class="n">dummy</span>
        <span class="n">current</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">while</span> <span class="n">current</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">current</span><span class="p">.</span><span class="n">val</span> <span class="o">==</span> <span class="n">val</span><span class="p">:</span>
                <span class="n">placeholder</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">current</span><span class="p">.</span><span class="nb">next</span>
                <span class="k">return</span> <span class="n">dummy</span><span class="p">.</span><span class="nb">next</span>
            <span class="n">placeholder</span> <span class="o">=</span> <span class="n">current</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="p">.</span><span class="nb">next</span>
        <span class="k">return</span> <span class="n">dummy</span><span class="p">.</span><span class="nb">next</span>         
</code></pre></div><div class="highlight"><pre class="highlight markdown tab-markdown"><code><span class="p">1.</span> Create <span class="sb">`dummy`</span> node
<span class="p">    -</span> <span class="sb">`dummy.next`</span> points to <span class="sb">`head`</span>
<span class="p">2.</span> Set <span class="sb">`placeholder`</span> to <span class="sb">`dummy`</span> and <span class="sb">`current`</span> to <span class="sb">`head`</span>
<span class="p">3.</span> Iterate through <span class="sb">`current`</span> by:
<span class="p">    -</span> Set <span class="sb">`placeholder`</span> to <span class="sb">`current`</span> node
<span class="p">    -</span> Set <span class="sb">`current`</span> to <span class="sb">`current.next`</span>
<span class="p">5.</span> If we find <span class="sb">`val`</span>:
<span class="p">    -</span> set <span class="sb">`placeholder.next`</span> to node at <span class="sb">`current.next`</span>
<span class="p">6.</span> Return <span class="sb">`dummy.next`</span>

</code></pre></div>
<p>Typically saves you creating <em>special edge condition logic</em> in order to operate on the head of a linked list with some algorithms. </p>

<aside class="notice">
Thanks to `dummy head`, deleting the head of the original list is the same as deleting any other element in the list.
</aside>
<h2 id='strategy-multi-pass'>Strategy:  Multi Pass</h2>
<blockquote>
<p>Get Length of List</p>
</blockquote>
<div class="highlight"><pre class="highlight python tab-python"><code>    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">current</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">length</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">current</span><span class="p">:</span>
            <span class="n">length</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="p">.</span><span class="nb">next</span>
        <span class="k">return</span> <span class="n">length</span>
</code></pre></div><div class="highlight"><pre class="highlight markdown tab-markdown"><code><span class="p">1.</span> Iterate through list
<span class="p">2.</span> Increment <span class="sb">`length`</span>
<span class="p">3.</span> Set <span class="sb">`current`</span> to <span class="sb">`current.next`</span>
</code></pre></div>
<p>Most computations on a list will require O(N) time complexity, so a simple but very useful technique is to pass through the list a constant number of times to calculate some summary of the list that will simplify your algorithm.</p>

<p>The looping is implicitly done for you by the execution of your program, namely every successive call to your recursive function places some data on your <code>call stack</code> and then goes to the next function.</p>
<h2 id='note-on-recursion-vs-iteration'>Note on Recursion vs. Iteration:</h2>
<blockquote>
<p>Recursive Length of List</p>
</blockquote>
<div class="highlight"><pre class="highlight python tab-python"><code>    <span class="k">def</span> <span class="nf">get_length_recursive</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">linklist</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">linklist</span><span class="p">:</span> 
            <span class="k">return</span> <span class="mi">0</span> <span class="c1"># A None path has 0 length
</span>        <span class="k">return</span> <span class="n">get_length_recursive</span><span class="p">(</span><span class="n">linklist</span><span class="p">.</span><span class="nb">next</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> 
        <span class="c1"># The length at this node is 1 + length of rest of list
</span></code></pre></div><div class="highlight"><pre class="highlight markdown tab-markdown"><code><span class="p">1.</span> Base Case: return <span class="sb">`0`</span> if <span class="sb">`None`</span>
<span class="p">2.</span> Recurse through call stack, 
adding <span class="sb">`+1`</span> to previous val of <span class="sb">`length`</span> on call stack
</code></pre></div>
<aside class="notice"> 
Recursive algorithms are often very easy to write with linked lists because the list is structured recursively.
</aside>

<aside class="warning">
Major drawback of recursive algorithm. For most situations, this means you are paying a storage penalty equal to the size of the list.
</aside>
<h2 id='strategy-two-pointer'>Strategy: Two Pointer</h2>
<p>Very useful technique for dealing with linked lists involves iterating through the list with 2 or more pointers. The differences between how the pointers iterate can be used to make calculations on the list more efficient.</p>

<table><thead>
<tr>
<th></th>
<th>Time</th>
<th>Space</th>
</tr>
</thead><tbody>
<tr>
<td>Using Hashmap</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>Two Pointer</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<h3 id='explanation'>Explanation:</h3>
<p>The first thing that most people think of is to use another data structure to store nodes that we have already seen as we traverse the list. Then as we move through the nodes of the list we check to see if we have already stored the current node in our auxiliary data structure and if we have then we have found a cycle. The typical data structure to choose here is a hash map because it offers constant time insertion and lookup. </p>

<p>We can get rid of the extra auxiliary data structure by utilizing only one additional pointer. We can then use the two pointers to iterate through the list at two different speeds. The motivation being that if there is a cycle, then the list can be thought of as a circle (at least the part of the list past the self-intersection). Similar to a race track, the faster pointer must eventually cross paths with the slower pointer, whereas if there is not a cycle they will never cross paths.</p>
<h1 id='references'>References</h1>
<ul>
<li>CodePath CS guides: <a href="https://guides.codepath.org/compsci">https://guides.codepath.org/compsci</a></li>
<li>InterviewCake: <a href="https://www.interviewcake.com/data-structures-reference">https://www.interviewcake.com/data-structures-reference</a></li>
<li>TSiege Tech Interview Cheat Sheet: <a href="https://github.com/TSiege/Tech-Interview-Cheat-Sheet">https://github.com/TSiege/Tech-Interview-Cheat-Sheet</a></li>
</ul>

      </div>
      <div class="dark-box">
          <div class="lang-selector">
                <a href="#" data-language-name="python">python</a>
                <a href="#" data-language-name="markdown">pseudocode</a>
          </div>
      </div>
    </div>
  </body>
</html>
